model.weights
p1
thetahatsleps
sethetahatsleps
lep1pred$std.error
theta.hats[1] + c(-1,1)*qt(0.975, residual.dfs[1])*se.theta.hats[1]
theta.hats[2] + c(-1,1)*qt(0.975, residual.dfs[2])*se.theta.hats[2]
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t=TRUE, residual.dfs=residual.dfs)
theta.hats = c(p1$fit, p2$fit)
se.theta.hats = c(p1$se.fit, p2$se.fit)
theta.hats[1] + c(-1,1)*qt(0.975, residual.dfs[1])*se.theta.hats[1]
theta.hats[2] + c(-1,1)*qt(0.975, residual.dfs[2])*se.theta.hats[2]
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t=TRUE, residual.dfs=residual.dfs)
model.weights
((3.033905*0.7222926) + (2.658266*0.2777074))/2
((3.033905*0.7222926) + (2.658266*0.2777074))
theta.hats[1] + c(-1,1)*qt(0.975)*se.theta.hats[1]
qt(0.975, residual.dfs[1])
theta.hats[1]
c(-1,1)*qt(0.975, residual.dfs[1])*se.theta.hats[1]
se.theta.hats
theta.hats
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t=TRUE, residual.dfs=residual.dfs)
theta.hats
se.theta.hats
residual.dfs[1]
lepmod.crossed_dredge$df
3.058910e-01 + c(-1,1)*qt(0.975, 12)*0.3924657
n = 20 # 'n' is assumed to be even
x1 = c(rep(0,n/2), rep(1,n/2)) # two groups: x1=0, and x1=1
x2 = rnorm(n, mean=10, sd=3)
y = rnorm(n, mean = 3*x1 + 0.1*x2) # data generation
x1 = factor(x1)
m1 = glm(y ~ x1) # using 'glm' provides AIC values.
m2 = glm(y ~ x1 + x2) # using 'lm' doesn't.
aic = c(m1$aic, m2$aic)
delta.aic = aic - min(aic)
model.weights = exp(-0.5*delta.aic) / sum(exp(-0.5*delta.aic))
residual.dfs = c(m1$df.residual, m2$df.residual)
p1 = predict(m1, se=TRUE, newdata=list(x1=factor(1), x2=15))
p2 = predict(m2, se=TRUE, newdata=list(x1=factor(1), x2=15))
theta.hats = c(p1$fit, p2$fit)
se.theta.hats = c(p1$se.fit, p2$se.fit)
tailarea.z = function(theta, theta.hats, se.theta.hats, model.weights, alpha) {
z.quantiles = (theta-theta.hats)/se.theta.hats
tailarea = sum(model.weights*stats::pnorm(z.quantiles)) - alpha
tailarea
}
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t=TRUE, residual.dfs=residual.dfs)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t=FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t =  FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t =  FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t =  FALSE)
n = 20 # 'n' is assumed to be even
x1 = c(rep(0,n/2), rep(1,n/2)) # two groups: x1=0, and x1=1
x2 = rnorm(n, mean=10, sd=3)
y = rnorm(n, mean = 3*x1 + 0.1*x2) # data generation
x1 = factor(x1)
m1 = glm(y ~ x1) # using 'glm' provides AIC values.
m2 = glm(y ~ x1 + x2) # using 'lm' doesn't.
aic = c(m1$aic, m2$aic)
delta.aic = aic - min(aic)
model.weights = exp(-0.5*delta.aic) / sum(exp(-0.5*delta.aic))
residual.dfs = c(m1$df.residual, m2$df.residual)
p1 = predict(m1, se=TRUE, newdata=list(x1=factor(1), x2=15))
p2 = predict(m2, se=TRUE, newdata=list(x1=factor(1), x2=15))
theta.hats = c(p1$fit, p2$fit)
se.theta.hats = c(p1$se.fit, p2$se.fit)
mata.wald = function(theta.hats, se.theta.hats, model.weights, mata.t, residual.dfs, alpha=0.025, normal.lm) {
if(length(theta.hats) != length(se.theta.hats))    stop('dimension mismatch in arguments')
if(length(theta.hats) != length(model.weights))    stop('dimension mismatch in arguments')
if(any(se.theta.hats <= 0))                        stop('negative se.theta.hats')
if(any(model.weights < 0))                         stop('negative model.weights')
if(abs(sum(model.weights)-1) > 0.001)              stop('model.weights do not sum to 1')
if(!is.logical(mata.t))                            stop('mata.t must be logical (T/F)')
if((alpha<=0) | (alpha>=0.5))                      stop('alpha outside of meaningful range')
if(!missing(normal.lm))                            stop('normal.lm argument has been deprecated, and replaced by \'mata.t\'')
if(mata.t) {
if(missing(residual.dfs))                        stop('must specify residual.dfs when mata.t = TRUE')
if(length(theta.hats) != length(residual.dfs))   stop('dimension mismatch in arguments')
if(any(residual.dfs <= 0))                       stop('negative residual.dfs')
if(any(residual.dfs != round(residual.dfs)))     stop('non-integer residual.dfs')
theta.L = stats::uniroot(f=tailarea.t, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=alpha,
residual.dfs=residual.dfs, tol=1e-10)$root
theta.U = stats::uniroot(f=tailarea.t, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=1-alpha,
residual.dfs=residual.dfs, tol=1e-10)$root
}
if(!mata.t) {
theta.L = stats::uniroot(f=tailarea.z, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=alpha, tol=1e-10)$root
theta.U = stats::uniroot(f=tailarea.z, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=1-alpha, tol=1e-10)$root
}
c(theta.L, theta.U)
}
tailarea.z = function(theta, theta.hats, se.theta.hats, model.weights, alpha) {
z.quantiles = (theta-theta.hats)/se.theta.hats
tailarea = sum(model.weights*stats::pnorm(z.quantiles)) - alpha
tailarea
}
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t =  FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
n = 20 # 'n' is assumed to be even
x1 = c(rep(0,n/2), rep(1,n/2)) # two groups: x1=0, and x1=1
x2 = rnorm(n, mean=10, sd=3)
y = rnorm(n, mean = 3*x1 + 0.1*x2) # data generation
x1 = factor(x1)
m1 = glm(y ~ x1) # using 'glm' provides AIC values.
m2 = glm(y ~ x1 + x2) # using 'lm' doesn't.
aic = c(m1$aic, m2$aic)
delta.aic = aic - min(aic)
model.weights = exp(-0.5*delta.aic) / sum(exp(-0.5*delta.aic))
residual.dfs = c(m1$df.residual, m2$df.residual)
p1 = predict(m1, se=TRUE, newdata=list(x1=factor(1), x2=15))
p2 = predict(m2, se=TRUE, newdata=list(x1=factor(1), x2=15))
theta.hats = c(p1$fit, p2$fit)
se.theta.hats = c(p1$se.fit, p2$se.fit)
mata.wald = function(theta.hats, se.theta.hats, model.weights, mata.t, residual.dfs, alpha=0.025, normal.lm) {
if(length(theta.hats) != length(se.theta.hats))    stop('dimension mismatch in arguments')
if(length(theta.hats) != length(model.weights))    stop('dimension mismatch in arguments')
if(any(se.theta.hats <= 0))                        stop('negative se.theta.hats')
if(any(model.weights < 0))                         stop('negative model.weights')
if(abs(sum(model.weights)-1) > 0.001)              stop('model.weights do not sum to 1')
if(!is.logical(mata.t))                            stop('mata.t must be logical (T/F)')
if((alpha<=0) | (alpha>=0.5))                      stop('alpha outside of meaningful range')
if(!missing(normal.lm))                            stop('normal.lm argument has been deprecated, and replaced by \'mata.t\'')
if(mata.t) {
if(missing(residual.dfs))                        stop('must specify residual.dfs when mata.t = TRUE')
if(length(theta.hats) != length(residual.dfs))   stop('dimension mismatch in arguments')
if(any(residual.dfs <= 0))                       stop('negative residual.dfs')
if(any(residual.dfs != round(residual.dfs)))     stop('non-integer residual.dfs')
theta.L = stats::uniroot(f=tailarea.t, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=alpha,
residual.dfs=residual.dfs, tol=1e-10)$root
theta.U = stats::uniroot(f=tailarea.t, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=1-alpha,
residual.dfs=residual.dfs, tol=1e-10)$root
}
if(!mata.t) {
theta.L = stats::uniroot(f=tailarea.z, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=alpha, tol=1e-10)$root
theta.U = stats::uniroot(f=tailarea.z, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=1-alpha, tol=1e-10)$root
}
c(theta.L, theta.U)
}
tailarea.z = function(theta, theta.hats, se.theta.hats, model.weights, alpha) {
z.quantiles = (theta-theta.hats)/se.theta.hats
tailarea = sum(model.weights*stats::pnorm(z.quantiles)) - alpha
tailarea
}
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
debugSource("<Model-Averaging-CIs-Rough-Work>")
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats, brower()
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats, brower(),
model.weights=model.weights, mata.t = FALSE)
n
als;dkfj
install.packages('wrapr')
library(wrapr)
debug()
debug(mata.wald)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats, brower(),
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats, brower(),
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats, brower(),
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats, brower(),
model.weights=model.weights, mata.t = FALSE)
undebug(meta.wald)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats, brower(),
model.weights=model.weights, mata.t = FALSE)
undebug(mata.wald)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats, brower(),
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats, brower(),
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats, browser(),
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
debug(mata.wald)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
n
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
?stats::uniroot
m3 = glm(y ~ x1*x2)
aic = c(m1$aic, m2$aic, m3$aic)
delta.aic = aic - min(aic)
model.weights = exp(-0.5*delta.aic) / sum(exp(-0.5*delta.aic))
residual.dfs = c(m1$df.residual, m2$df.residual, m3$df.residual)
p2 = predict(m3, se=TRUE, newdata=list(x1=factor(1), x2=15))
p2 = predict(m2, se=TRUE, newdata=list(x1=factor(1), x2=15))
p3 = predict(m3, se=TRUE, newdata=list(x1=factor(1), x2=15))
m3 = glm(y ~ x1*x2)
aic = c(m1$aic, m2$aic, m3$aic)
delta.aic = aic - min(aic)
model.weights = exp(-0.5*delta.aic) / sum(exp(-0.5*delta.aic))
residual.dfs = c(m1$df.residual, m2$df.residual, m3$df.residual)
p1 = predict(m1, se=TRUE, newdata=list(x1=factor(1), x2=15))
p2 = predict(m2, se=TRUE, newdata=list(x1=factor(1), x2=15))
p3 = predict(m3, se=TRUE, newdata=list(x1=factor(1), x2=15))
theta.hats = c(p1$fit, p2$fit, p3$fit)
se.theta.hats = c(p1$se.fit, p2$se.fit, p3$se.fit)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
undebug(mata.wald)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
theta.hats[3] + c(-1,1)*qt(0.975, residual.dfs[3])*se.theta.hats[3]
theta.hats[1] + c(-1,1)*qt(0.975, residual.dfs[1])*se.theta.hats[1]
theta.hats[2] + c(-1,1)*qt(0.975, residual.dfs[2])*se.theta.hats[2]
theta.hats[3] + c(-1,1)*qt(0.975, residual.dfs[3])*se.theta.hats[3]
model.weights
((3.289499*0.3313084) + (3.228804*0.1733297) + (3.735886*0.4953619))
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
aic
model.weights
theta.hats[1] + c(-1,1)*qt(0.975, residual.dfs[1])*se.theta.hats[1]
theta.hats[2] + c(-1,1)*qt(0.975, residual.dfs[2])*se.theta.hats[2]
theta.hats
theta.hats[3] + c(-1,1)*qt(0.975, residual.dfs[3])*se.theta.hats[3]
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = TRUE, residual.dfs = residual.dfs)
tailarea.z = function(theta, theta.hats, se.theta.hats, model.weights, alpha) {
z.quantiles = (theta-theta.hats)/se.theta.hats
tailarea = sum(model.weights*stats::pnorm(z.quantiles)) - alpha
tailarea
}
mata.wald = function(theta.hats, se.theta.hats, model.weights, mata.t, residual.dfs, alpha=0.025, normal.lm) {
if(length(theta.hats) != length(se.theta.hats))    stop('dimension mismatch in arguments')
if(length(theta.hats) != length(model.weights))    stop('dimension mismatch in arguments')
if(any(se.theta.hats <= 0))                        stop('negative se.theta.hats')
if(any(model.weights < 0))                         stop('negative model.weights')
if(abs(sum(model.weights)-1) > 0.001)              stop('model.weights do not sum to 1')
if(!is.logical(mata.t))                            stop('mata.t must be logical (T/F)')
if((alpha<=0) | (alpha>=0.5))                      stop('alpha outside of meaningful range')
if(!missing(normal.lm))                            stop('normal.lm argument has been deprecated, and replaced by \'mata.t\'')
if(mata.t) {
if(missing(residual.dfs))                        stop('must specify residual.dfs when mata.t = TRUE')
if(length(theta.hats) != length(residual.dfs))   stop('dimension mismatch in arguments')
if(any(residual.dfs <= 0))                       stop('negative residual.dfs')
if(any(residual.dfs != round(residual.dfs)))     stop('non-integer residual.dfs')
theta.L = stats::uniroot(f=tailarea.t, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=alpha,
residual.dfs=residual.dfs, tol=1e-10)$root
theta.U = stats::uniroot(f=tailarea.t, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=1-alpha,
residual.dfs=residual.dfs, tol=1e-10)$root
}
if(!mata.t) {
theta.L = stats::uniroot(f=tailarea.z, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=alpha, tol=1e-10)$root
theta.U = stats::uniroot(f=tailarea.z, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=1-alpha, tol=1e-10)$root
}
c(theta.L, theta.U)
}
}
mata.wald = function(theta.hats, se.theta.hats, model.weights, mata.t, residual.dfs, alpha=0.025, normal.lm) {
if(length(theta.hats) != length(se.theta.hats))    stop('dimension mismatch in arguments')
if(length(theta.hats) != length(model.weights))    stop('dimension mismatch in arguments')
if(any(se.theta.hats <= 0))                        stop('negative se.theta.hats')
if(any(model.weights < 0))                         stop('negative model.weights')
if(abs(sum(model.weights)-1) > 0.001)              stop('model.weights do not sum to 1')
if(!is.logical(mata.t))                            stop('mata.t must be logical (T/F)')
if((alpha<=0) | (alpha>=0.5))                      stop('alpha outside of meaningful range')
if(!missing(normal.lm))                            stop('normal.lm argument has been deprecated, and replaced by \'mata.t\'')
if(mata.t) {
if(missing(residual.dfs))                        stop('must specify residual.dfs when mata.t = TRUE')
if(length(theta.hats) != length(residual.dfs))   stop('dimension mismatch in arguments')
if(any(residual.dfs <= 0))                       stop('negative residual.dfs')
if(any(residual.dfs != round(residual.dfs)))     stop('non-integer residual.dfs')
theta.L = stats::uniroot(f=tailarea.t, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=alpha,
residual.dfs=residual.dfs, tol=1e-10)$root
theta.U = stats::uniroot(f=tailarea.t, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=1-alpha,
residual.dfs=residual.dfs, tol=1e-10)$root
}
if(!mata.t) {
theta.L = stats::uniroot(f=tailarea.z, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=alpha, tol=1e-10)$root
theta.U = stats::uniroot(f=tailarea.z, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=1-alpha, tol=1e-10)$root
}
c(theta.L, theta.U)
}
mata.wald = function(theta.hats, se.theta.hats, model.weights, mata.t, residual.dfs, alpha=0.025, normal.lm) {
if(length(theta.hats) != length(se.theta.hats))    stop('dimension mismatch in arguments')
if(length(theta.hats) != length(model.weights))    stop('dimension mismatch in arguments')
if(any(se.theta.hats <= 0))                        stop('negative se.theta.hats')
if(any(model.weights < 0))                         stop('negative model.weights')
if(abs(sum(model.weights)-1) > 0.001)              stop('model.weights do not sum to 1')
if(!is.logical(mata.t))                            stop('mata.t must be logical (T/F)')
if((alpha<=0) | (alpha>=0.5))                      stop('alpha outside of meaningful range')
if(!missing(normal.lm))                            stop('normal.lm argument has been deprecated, and replaced by \'mata.t\'')
if(mata.t) {
if(missing(residual.dfs))                        stop('must specify residual.dfs when mata.t = TRUE')
if(length(theta.hats) != length(residual.dfs))   stop('dimension mismatch in arguments')
if(any(residual.dfs <= 0))                       stop('negative residual.dfs')
if(any(residual.dfs != round(residual.dfs)))     stop('non-integer residual.dfs')
theta.L = stats::uniroot(f=tailarea.t, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=alpha,
residual.dfs=residual.dfs, tol=1e-10)$root
theta.U = stats::uniroot(f=tailarea.t, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=1-alpha,
residual.dfs=residual.dfs, tol=1e-10)$root
}
if(!mata.t) {
theta.L = stats::uniroot(f=tailarea.z, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=alpha, tol=1e-10)$root
theta.U = stats::uniroot(f=tailarea.z, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=1-alpha, tol=1e-10)$root
}
c(theta.L, theta.U)
tailarea.z = function(theta, theta.hats, se.theta.hats, model.weights, alpha) {
z.quantiles = (theta-theta.hats)/se.theta.hats
tailarea = sum(model.weights*stats::pnorm(z.quantiles)) - alpha
tailarea
}
}
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = TRUE, residual.dfs = residual.dfs)
debug(mata.wald)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = TRUE, residual.dfs = residual.dfs)
m2 = glm(y ~ x1 + x2) # using 'lm' doesn't.
m3 = glm(y ~ x1*x2)
aic = c(m1$aic, m2$aic, m3$aic)
delta.aic = aic - min(aic)
model.weights = exp(-0.5*delta.aic) / sum(exp(-0.5*delta.aic))
residual.dfs = c(m1$df.residual, m2$df.residual, m3$df.residual)
p1 = predict(m1, se=TRUE, newdata=list(x1=factor(1), x2=15))
p2 = predict(m2, se=TRUE, newdata=list(x1=factor(1), x2=15))
p3 = predict(m3, se=TRUE, newdata=list(x1=factor(1), x2=15))
theta.hats = c(p1$fit, p2$fit, p3$fit)
se.theta.hats = c(p1$se.fit, p2$se.fit, p3$se.fit)
theta.hats[1] + c(-1,1)*qt(0.975, residual.dfs[1])*se.theta.hats[1]
theta.hats[2] + c(-1,1)*qt(0.975, residual.dfs[2])*se.theta.hats[2]
theta.hats[3] + c(-1,1)*qt(0.975, residual.dfs[3])*se.theta.hats[3]
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t=TRUE)
undebug(mata.wald)
m3 = glm(y ~ x1*x2)
aic = c(m1$aic, m2$aic, m3$aic)
delta.aic = aic - min(aic)
model.weights = exp(-0.5*delta.aic) / sum(exp(-0.5*delta.aic))
residual.dfs = c(m1$df.residual, m2$df.residual, m3$df.residual)
p1 = predict(m1, se=TRUE, newdata=list(x1=factor(1), x2=15))
p2 = predict(m2, se=TRUE, newdata=list(x1=factor(1), x2=15))
p3 = predict(m3, se=TRUE, newdata=list(x1=factor(1), x2=15))
theta.hats = c(p1$fit, p2$fit, p3$fit)
se.theta.hats = c(p1$se.fit, p2$se.fit, p3$se.fit)
theta.hats[1] + c(-1,1)*qt(0.975, residual.dfs[1])*se.theta.hats[1]
theta.hats[2] + c(-1,1)*qt(0.975, residual.dfs[2])*se.theta.hats[2]
theta.hats[3] + c(-1,1)*qt(0.975, residual.dfs[3])*se.theta.hats[3]
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t=FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t=FALSE)
x = MATA::mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t=FALSE)
x
((3.289499*0.3313084) + (3.228804*0.1733297) + (3.735886*0.4953619))
?qt
3.058910e-01 + c(-1,1)*qt(0.975, 12)*0.3924657
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = TRUE, residual.dfs = residual.dfs)
tailarea.t = function(theta, theta.hats, se.theta.hats, model.weights, alpha, residual.dfs) {
t.quantiles = (theta-theta.hats)/se.theta.hats
tailarea = sum(model.weights*stats::pt(t.quantiles, df=residual.dfs)) - alpha
tailarea
}
tailarea.z = function(theta, theta.hats, se.theta.hats, model.weights, alpha) {
z.quantiles = (theta-theta.hats)/se.theta.hats
tailarea = sum(model.weights*stats::pnorm(z.quantiles)) - alpha
tailarea
}
tailarea.t = function(theta, theta.hats, se.theta.hats, model.weights, alpha, residual.dfs) {
t.quantiles = (theta-theta.hats)/se.theta.hats
tailarea = sum(model.weights*stats::pt(t.quantiles, df=residual.dfs)) - alpha
tailarea
}
mata.wald = function(theta.hats, se.theta.hats, model.weights, mata.t, residual.dfs, alpha=0.025, normal.lm) {
if(length(theta.hats) != length(se.theta.hats))    stop('dimension mismatch in arguments')
if(length(theta.hats) != length(model.weights))    stop('dimension mismatch in arguments')
if(any(se.theta.hats <= 0))                        stop('negative se.theta.hats')
if(any(model.weights < 0))                         stop('negative model.weights')
if(abs(sum(model.weights)-1) > 0.001)              stop('model.weights do not sum to 1')
if(!is.logical(mata.t))                            stop('mata.t must be logical (T/F)')
if((alpha<=0) | (alpha>=0.5))                      stop('alpha outside of meaningful range')
if(!missing(normal.lm))                            stop('normal.lm argument has been deprecated, and replaced by \'mata.t\'')
if(mata.t) {
if(missing(residual.dfs))                        stop('must specify residual.dfs when mata.t = TRUE')
if(length(theta.hats) != length(residual.dfs))   stop('dimension mismatch in arguments')
if(any(residual.dfs <= 0))                       stop('negative residual.dfs')
if(any(residual.dfs != round(residual.dfs)))     stop('non-integer residual.dfs')
theta.L = stats::uniroot(f=tailarea.t, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=alpha,
residual.dfs=residual.dfs, tol=1e-10)$root
theta.U = stats::uniroot(f=tailarea.t, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=1-alpha,
residual.dfs=residual.dfs, tol=1e-10)$root
}
if(!mata.t) {
theta.L = stats::uniroot(f=tailarea.z, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=alpha, tol=1e-10)$root
theta.U = stats::uniroot(f=tailarea.z, interval=c(-1e10, 1e10),
theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, alpha=1-alpha, tol=1e-10)$root
}
c(theta.L, theta.U)
}
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = TRUE, residual.dfs = residual.dfs)
((3.289499*0.3313084) + (3.228804*0.1733297) + (3.735886*0.4953619))
z.quantiles = (theta-theta.hats)/se.theta.hats
calallpred$conf.low[8]
alsCI1[1]
calsCI1[1]
debug(mata.wald)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
c
=
mata.wald(theta.hats=theta.hats, se.theta.hats=se.theta.hats,
model.weights=model.weights, mata.t = FALSE)
?uniroot
c(-1,1)*qt(0.975, residual.dfs[1])
summary(cal1)
cal1$sdr
cal1$modelInfo
summary(cal1)
summary(cal2)
summary(cal8)
residual.dfs
aic
cal1pred
cal1$sdr
sethetahatscals
cal1$sdr[1]
x = ggpredict(m3)
x
se.theta.hats
